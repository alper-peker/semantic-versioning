name: Component-aware SemVer Workflow

on:
  pull_request:
    types: [closed]

permissions:
  contents: write
  pull-requests: read

concurrency:
  group: semver-${{ github.ref }}
  cancel-in-progress: false

jobs:
  prepare_meta:
    name: Detect changed components & SemVer bump
    runs-on: ubuntu-latest
    if: >
      github.event.pull_request.merged == true &&
      github.event.pull_request.base.ref == 'main'
    outputs:
      changed: ${{ steps.detect.outputs.changed }}
      bump: ${{ steps.bump.outputs.bump }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Detect changed components
        id: detect
        shell: bash
        run: |
          set -euo pipefail

          BASE_SHA="${{ github.event.pull_request.base.sha }}"

          HEAD_SHA="${{ github.event.pull_request.merge_commit_sha || github.event.pull_request.head.sha }}"

          echo "Base: ${BASE_SHA}"
          echo "Head: ${HEAD_SHA}"

          git diff --name-only "${BASE_SHA}" "${HEAD_SHA}" > changed.txt || true
          cat changed.txt || true

          FRONT=$(grep -E '^src/front-end/'  changed.txt || true)
          BACK=$(grep -E '^src/back-end/'    changed.txt || true)
          FUNCS=$(grep -E '^src/functions/'  changed.txt || true)
          INFRA=$(grep -E '^src/infra/'      changed.txt || true)

          OUT=""

          [[ -n "${FRONT:-}"  ]] && OUT+="${OUT:+,}fend"
          [[ -n "${BACK:-}"   ]] && OUT+="${OUT:+,}bend"
          [[ -n "${FUNCS:-}"  ]] && OUT+="${OUT:+,}func"
          [[ -n "${INFRA:-}"  ]] && OUT+="${OUT:+,}infra"

          echo "changed=${OUT}" >> "$GITHUB_OUTPUT"
          echo "Detected changed component(s): ${OUT:-none}"

      - name: Determine SemVer bump from labels
        id: bump
        uses: actions/github-script@v7
        with:
          script: |
            const labels = (context.payload.pull_request.labels || []).map(l => l.name);
            core.info(`PR labels: ${labels.join(', ') || '(none)'}`);

            let bump = 'patch';

            if (labels.includes('breaking-change')) {
              bump = 'major';
            } else if (labels.includes('feature')) {
              bump = 'minor';
            }

            core.info(`Selected bump level: ${bump}`);
            core.setOutput('bump', bump);

  compute_versions:
    name: Compute next version per component
    runs-on: ubuntu-latest
    needs: prepare_meta
    if: needs.prepare_meta.outputs.changed != ''
    outputs:
      frontend_next: ${{ steps.calc.outputs.frontend_next }}
      backend_next: ${{ steps.calc.outputs.backend_next }}
      functions_next: ${{ steps.calc.outputs.functions_next }}
      infra_next: ${{ steps.calc.outputs.infra_next }}
    env:
      BUMP_LEVEL: ${{ needs.prepare_meta.outputs.bump }}
      CHANGED: ${{ needs.prepare_meta.outputs.changed }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch tags
        run: |
          git fetch --tags --force

      - name: Compute next versions
        id: calc
        shell: bash
        run: |
          set -euo pipefail

          BUMP="${BUMP_LEVEL}"
          CHANGED="${CHANGED}"

          echo "Bump level: ${BUMP}"
          echo "Changed components: ${CHANGED}"

          bump_one() {
            local prefix="$1"
            local pattern="${prefix}-v*"

            local last
            last=$(git tag --list "$pattern" | sort -V | tail -n 1 || true)

            local base
            if [[ -z "$last" ]]; then
              base="0.0.0"
            else
              base="${last#${prefix}-v}"
            fi

            IFS='.' read -r major minor patch <<< "$base"

            case "$BUMP" in
              major)
                major=$((major + 1))
                minor=0
                patch=0
                ;;
              minor)
                minor=$((minor + 1))
                patch=0
                ;;
              patch|*)
                patch=$((patch + 1))
                ;;
            esac

            local next="${prefix}-v${major}.${minor}.${patch}"
            echo "$next"
          }

          FRONT_NEXT=""
          BACK_NEXT=""
          FUNCS_NEXT=""
          INFRA_NEXT=""

          if [[ ",$CHANGED," == *",fend,"* ]]; then
            FRONT_NEXT="$(bump_one "frontend")"
          fi

          if [[ ",$CHANGED," == *",bend,"* ]]; then
            BACK_NEXT="$(bump_one "backend")"
          fi

          if [[ ",$CHANGED," == *",func,"* ]]; then
            FUNCS_NEXT="$(bump_one "functions")"
          fi

          if [[ ",$CHANGED," == *",infra,"* ]]; then
            INFRA_NEXT="$(bump_one "infra")"
          fi

          echo "frontend_next=$FRONT_NEXT"  >> "$GITHUB_OUTPUT"
          echo "backend_next=$BACK_NEXT"    >> "$GITHUB_OUTPUT"
          echo "functions_next=$FUNCS_NEXT" >> "$GITHUB_OUTPUT"
          echo "infra_next=$INFRA_NEXT"     >> "$GITHUB_OUTPUT"

          echo "Computed next versions:"
          echo "  frontend : ${FRONT_NEXT:-none}"
          echo "  backend  : ${BACK_NEXT:-none}"
          echo "  functions: ${FUNCS_NEXT:-none}"
          echo "  infra    : ${INFRA_NEXT:-none}"

  create_and_push_tags:
    name: Create and push tags
    runs-on: ubuntu-latest
    needs: compute_versions
    if: >
      needs.compute_versions.outputs.frontend_next != '' ||
      needs.compute_versions.outputs.backend_next != ''  ||
      needs.compute_versions.outputs.functions_next != '' ||
      needs.compute_versions.outputs.infra_next != ''
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions@users.noreply.github.com"

      - name: Create and push tags
        shell: bash
        run: |
          set -euo pipefail

          F_TAG="${{ needs.compute_versions.outputs.frontend_next }}"
          B_TAG="${{ needs.compute_versions.outputs.backend_next }}"
          FN_TAG="${{ needs.compute_versions.outputs.functions_next }}"
          INF_TAG="${{ needs.compute_versions.outputs.infra_next }}"

          echo "Tags to create:"
          echo "  frontend : ${F_TAG:-none}"
          echo "  backend  : ${B_TAG:-none}"
          echo "  functions: ${FN_TAG:-none}"
          echo "  infra    : ${INF_TAG:-none}"

          if [[ -n "${F_TAG}" ]]; then
            echo "Creating tag: ${F_TAG}"
            git tag -a "${F_TAG}" -m "Frontend release via PR #${{ github.event.pull_request.number }}"
          fi

          if [[ -n "${B_TAG}" ]]; then
            echo "Creating tag: ${B_TAG}"
            git tag -a "${B_TAG}" -m "Backend release via PR #${{ github.event.pull_request.number }}"
          fi

          if [[ -n "${FN_TAG}" ]]; then
            echo "Creating tag: ${FN_TAG}"
            git tag -a "${FN_TAG}" -m "Functions release via PR #${{ github.event.pull_request.number }}"
          fi

          if [[ -n "${INF_TAG}" ]]; then
            echo "Creating tag: ${INF_TAG}"
            git tag -a "${INF_TAG}" -m "Infra release via PR #${{ github.event.pull_request.number }}"
          fi

          echo "Pushing tags..."
          git push --tags

  major_release:
    name: Create Major Release
    runs-on: ubuntu-latest
    needs: [prepare_meta, compute_versions, create_and_push_tags]
    if: needs.prepare_meta.outputs.bump == 'major'
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Generate Release Notes and Create Release
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY_LABEL }}
          FRONT_TAG: ${{ needs.compute_versions.outputs.frontend_next }}
          BACK_TAG: ${{ needs.compute_versions.outputs.backend_next }}
          FUNCS_TAG: ${{ needs.compute_versions.outputs.functions_next }}
          INFRA_TAG: ${{ needs.compute_versions.outputs.infra_next }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          REPO: ${{ github.repository }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
        run: |
          set -euo pipefail

          create_release() {
            local tag="$1"
            local component="$2"

            if [[ -z "$tag" ]]; then
              return
            fi

            echo "Processing release for $component ($tag)..."

            git fetch --tags --force

            echo "Finding last release for $component..."
            
            local prev_tag=""
            local release_tags
            release_tags=$(gh release list --limit 100 --json tagName --jq ".[].tagName" | grep "^${component}-v" || true)
            
            for t in $release_tags; do
              if [[ "$t" != "$tag" ]]; then
                prev_tag="$t"
                break
              fi
            done

            echo "Current tag: $tag"
            echo "Previous release tag: ${prev_tag:-none}"

            local diff_output=""
            if [[ -n "$prev_tag" ]]; then
              echo "Generating diff between $prev_tag and $tag..."
              diff_output=$(git diff "$prev_tag" "$tag" | head -c 3000 || true)
            else
              echo "No previous release found. Using empty diff or initial commit diff."
              diff_output=$(gh pr diff $PR_NUMBER --repo $REPO | head -c 3000 || true)
            fi


            PROMPT="You are a technical writer. Generate a release note for a major version release of the '$component' component.
            
            Context:
            - Component: $component
            - Version: $tag
            - Previous Version: ${prev_tag:-none}
            - PR Title: $PR_TITLE
            - PR Body: $PR_BODY
            
            Diff Summary (between previous and current version):
            $diff_output
            
            Instructions:
            Generate the release notes using EXACTLY the following format:
            
            Title: Release $tag
            This release is created to provide the $tag for the $component.
            
            [Breaking Changes Section]: Describe the breaking changes in a human-readable manner using full sentences.
            
            Changes:
            - [List new features and functionalities added since the last release]
            
            Fixes:
            - [List bugs or problems fixed since the last release]
            
            Do not include raw diffs. Ensure the tone is professional."

            PAYLOAD=$(jq -n \
              --arg model "gpt-4o-mini" \
              --arg system "You are a helpful assistant that generates release notes." \
              --arg user "$PROMPT" \
              '{
                model: $model,
                messages: [
                  {role: "system", content: $system},
                  {role: "user", content: $user}
                ],
                temperature: 0.3
              }')

            RESPONSE=$(curl -s -X POST https://api.openai.com/v1/chat/completions \
              -H "Content-Type: application/json" \
              -H "Authorization: Bearer $OPENAI_API_KEY" \
              -d "$PAYLOAD")

            if echo "$RESPONSE" | jq -e '.error' > /dev/null; then
              echo "OpenAI API Error: $(echo $RESPONSE | jq -r '.error.message')"
              NOTES="Major release for $component. See PR #$PR_NUMBER for details."
            else
              NOTES=$(echo "$RESPONSE" | jq -r '.choices[0].message.content')
            fi

            TITLE="$tag"
            
            echo "Creating GitHub Release for $tag..."
            gh release create "$tag" \
              --title "$TITLE" \
              --notes "$NOTES" \
              --repo "$REPO"
          }

          create_release "$FRONT_TAG" "frontend"
          create_release "$BACK_TAG" "backend"
          create_release "$FUNCS_TAG" "functions"
          create_release "$INFRA_TAG" "infra"
