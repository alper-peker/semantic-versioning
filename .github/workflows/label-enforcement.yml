name: Label Enforcement

on:
  pull_request:
    types: [opened, synchronize, reopened, edited, ready_for_review, labeled, unlabeled]

permissions:
  contents: read
  pull-requests: write
  issues: write
env:
  APPROVAL_USERS: 'AlperPeker, alper-peker'

jobs:
  label-check:
    runs-on: ubuntu-latest
    steps:
      - name: Require approvals and SemVer labels
        uses: actions/github-script@v7
        with:
          script: |
            const { owner, repo } = context.repo;
            const number = context.payload.pull_request.number;

            async function getLabels() {
              const res = await github.rest.issues.listLabelsOnIssue({ owner, repo, issue_number: number });
              return res.data.map(l => l.name);
            }

            async function waitForApproved(maxTries = 6) {
              for (let i = 0; i < maxTries; i++) {
                const labels = await getLabels();
                if (labels.includes("labels:approved")) return labels;
                await new Promise(r => setTimeout(r, 1000));
              }
              return await getLabels();
            }

            const approvers = process.env.APPROVAL_USERS.split(',').map(s => s.trim());
            const labels = await waitForApproved();

            if (!labels.includes("labels:approved")) {
              const comments = await github.rest.issues.listComments({ owner, repo, issue_number: number, per_page: 100 });
              const approvedBy = new Set(
                comments.data
                  .filter(c => c.body?.trim().startsWith("/approve-label"))
                  .map(c => c.user.login)
                  .filter(u => approvers.includes(u))
              );
              const pending = approvers.filter(u => !approvedBy.has(u));

              core.warning(`Pending approvals: ${pending.length ? pending.join(', ') : 'none'}`);

              const recent = comments.data.slice(-10).some(c =>
                (c.body || '').includes('Pending approvals:') &&
                pending.every(u => (c.body || '').includes(`@${u}`))
              );
              if (!recent) {
                await github.rest.issues.createComment({
                  owner, repo, issue_number: number,
                  body: `Pending approvals: ${pending.length ? pending.map(u => `@${u}`).join(', ') : 'none'}`
                });
              }

              core.setFailed(`Your labels must be approved by: ${approvers.join(', ')} to merge into main.`);
              return;
            }

            const semver = new Set([
              "breaking change","feature",
              "fix","perf","refactor","docs","test","build","ci","deps","revert","security"
            ]);
            const found = labels.filter(l => semver.has(l));

            if (found.length < 1) {
              core.setFailed("At least one SemVer-impact label is required: breaking change, feature, fix, perf, refactor, docs, test, build, ci, deps, revert, security.");
              return;
            }

            core.info(`labels:approved present; SemVer labels: ${found.join(', ')}`);
